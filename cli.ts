// deno run --allow-read --allow-write --allow-env --allow-ffi cli.ts --in ./sample/payload-types.ts --out ./export/payload-depth-types.ts
// A small CLI wrapper around the library generator functions.

import oxc from "oxc-parser";
import { parseArgs as jsrParseArgs } from "jsr:@std/cli/parse-args";
import { generateDepthInterfaces } from "@/depth-types-generator/index.ts";
import { dirname, fromFileUrl, join } from "https://deno.land/std/path/mod.ts";
import { copyDir } from "@/utils/copy-dir.ts";

const AUTO_GENERATED_FILE_HEADER = [
	"/**",
	" * Auto-generated by payloadcms-typing-supercharge. Do not edit.",
	" */"
].join("\n") + "\n\n";

// Absolute path of the current file
const currentFile = fromFileUrl(import.meta.url);
const currentDir = dirname(currentFile);
const pkgCopyDir = join(currentDir, "../copy");


type CliOptions = {
	inFile: string;
	outDir: string;
	maxDepth: number;
	onlyNames?: string[];
};

const showHelp = () => {
	console.log(`
payloadcms-typing-supercharge - Generate depth-aware TypeScript interfaces

USAGE:
	deno run --allow-read --allow-write --allow-env --allow-ffi cli.ts [OPTIONS]

OPTIONS:
	-h, --help                 Show this help message
			--in <file>            Input TypeScript file (default: ./sample/payload-types.ts)
			--out <dir>           Output directory (default: ./export/payloadcms-typing-supercharge)
			--depth <n>            Max depth to emit (0..n, default: 6)

EXAMPLES:
	deno run -A cli.ts --in ./sample/payload-types.ts --out ./export/payload-depth-types.ts --depth 2
	deno run -A cli.ts --in ./sample/payload-types.ts --names Post,User
`);
};

const parseArgs = (argv: string[]): CliOptions => {
	const args = jsrParseArgs(argv, {
		string: ["in", "out", "depth", "names"],
		boolean: ["help"],
		alias: { h: "help" },
		default: {
			in: "./sample/payload-types.ts",
			out: "./export/payload-depth-types.ts",
			depth: "6",
		},
	});

	if (args.help) {
		showHelp();
		Deno.exit(0);
	}

	const inFile = String(args.in);
	const outDir = String(args.out);
	const depthNum = Number.parseInt(String(args.depth), 10);
	const maxDepth = Number.isFinite(depthNum) ? depthNum : 2;

	// --names can be a comma-separated string; trim and filter empties
	const namesRaw = args.names ? String(args.names) : "";
	const onlyNames = namesRaw
		? namesRaw.split(",").map((s) => s.trim()).filter((s) => s.length > 0)
		: undefined;

	return { inFile, outDir, maxDepth, onlyNames };
};

export const main = async () => {
	const opts = parseArgs(Deno.args);
	const code = await Deno.readTextFile(opts.inFile);
	const result = oxc.parseSync(opts.inFile, code);
	if (result.errors && result.errors.length > 0) {
		console.error("Parse errors:", result.errors);
	}

	const text = generateDepthInterfaces(result.program, opts.maxDepth, {
		onlyNames: opts.onlyNames,
	});

	console.log({ currentFile, currentDir, copyDir: pkgCopyDir });

	// Copy and paste the files inside the copy folder to the output directory
	copyDir(pkgCopyDir, opts.outDir);

	// Replace the <output-dir>/types/depth.ts
	const targetFilePath = join(opts.outDir, "types/depth.ts");
	Deno.writeTextFileSync(targetFilePath, AUTO_GENERATED_FILE_HEADER + text);
	console.log(`Wrote ${targetFilePath}`);
};

if (import.meta.main) {
	main();
}
