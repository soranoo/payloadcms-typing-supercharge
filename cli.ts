// deno run --allow-read --allow-write --allow-env --allow-ffi cli.ts --in ./sample/payload-types.ts --out ./export/payload-depth-types.ts
// A small CLI wrapper around the library generator functions.

import oxc from "oxc-parser";
import { parseArgs as jsrParseArgs } from "jsr:@std/cli/parse-args";
import { generateDepthInterfaces } from "@/depth-types-generator/index.ts";
import { dirname, fromFileUrl } from "https://deno.land/std/path/mod.ts";

const AUTO_GENERATED_FILE_HEADER = [
	"/**",
	" * Auto-generated by payloadcms-typing-supercharge. Do not edit.",
	" */"
].join("\n") + "\n\n";

// Absolute path of the current file
const currentFile = fromFileUrl(import.meta.url);
const currentDir = dirname(currentFile);
const parentDir = dirname(currentDir);


type CliOptions = {
	inFile: string;
	outFile: string;
	maxDepth: number;
	onlyNames?: string[];
};

const showHelp = () => {
	console.log(`
payloadcms-typing-supercharge - Generate depth-aware TypeScript interfaces

USAGE:
	deno run --allow-read --allow-write --allow-env --allow-ffi cli.ts [OPTIONS]

OPTIONS:
	-h, --help                 Show this help message
			--in <file>            Input TypeScript file (default: ./sample/payload-types.ts)
			--out <dir>           Output directory (default: ./export/payloadcms-typing-supercharge)
			--depth <n>            Max depth to emit (0..n, default: 6)

EXAMPLES:
	deno run -A cli.ts --in ./sample/payload-types.ts --out ./export/payload-depth-types.ts --depth 2
	deno run -A cli.ts --in ./sample/payload-types.ts --names Post,User
`);
};

const parseArgs = (argv: string[]): CliOptions => {
	const args = jsrParseArgs(argv, {
		string: ["in", "out", "depth", "names"],
		boolean: ["help"],
		alias: { h: "help" },
		default: {
			in: "./sample/payload-types.ts",
			out: "./export/payload-depth-types.ts",
			depth: "6",
		},
	});

	if (args.help) {
		showHelp();
		Deno.exit(0);
	}

	const inFile = String(args.in);
	const outFile = String(args.out);
	const depthNum = Number.parseInt(String(args.depth), 10);
	const maxDepth = Number.isFinite(depthNum) ? depthNum : 2;

	// --names can be a comma-separated string; trim and filter empties
	const namesRaw = args.names ? String(args.names) : "";
	const onlyNames = namesRaw
		? namesRaw.split(",").map((s) => s.trim()).filter((s) => s.length > 0)
		: undefined;

	return { inFile, outFile, maxDepth, onlyNames };
};

const main = async () => {
	const opts = parseArgs(Deno.args);
	const code = await Deno.readTextFile(opts.inFile);
	const result = oxc.parseSync(opts.inFile, code);
	if (result.errors && result.errors.length > 0) {
		console.error("Parse errors:", result.errors);
	}

	const text = generateDepthInterfaces(result.program, opts.maxDepth, {
		onlyNames: opts.onlyNames,
	});

	console.log({currentFile, currentDir, parentDir})

	await Deno.writeTextFile(opts.outFile, AUTO_GENERATED_FILE_HEADER + text);
	console.log(`Wrote ${opts.outFile}`);
};

if (import.meta.main) {
	main();
}
